
        DEPTH = 1024 ;               -- The size of memory in words
        WIDTH = 16;                   -- bits per data word
        ADDRESS_RADIX = HEX;          
        DATA_RADIX = HEX;             
        CONTENT                       
        BEGIN
    
-- #########################################################################
-- assembly source code.
-- to write some data on the UART.

-- register file configuration

-- application-specific register aliases.

-- alias_both av_ctrl          [incr counter]
--    vdefine av_write_mask                   0x0001
-- alias_src  av_waitrequest   [incr counter]



-- :begin -- = 0x0000
    0000 : 2601 ; -- <0033> leds = 1
-- atx_ctrl = 0

-- a = 65
-- push a
-- a = 66
-- push a
-- a = 67
-- push a
-- a = 68
-- push a
-- a = 69
-- push a

-- pop b
-- putchar b
-- pop b
-- putchar b
-- pop b
-- putchar b
-- pop b
-- putchar b
-- pop b
-- putchar b

-- a = 0x1234
-- call put4x

-- x = 0x1234
-- y = 1
-- a = 0
-- :nextwrite
-- m9k_addr = a
-- m9k_data = x
-- x = x+y
-- b = 1
-- nop
-- a = a+b
-- b = 1024
-- nop
-- br lt :nextwrite

--patch
    0001 : 1200 ; -- <0076> x = 0
    0002 : 1601 ; -- <0077> y = 1
-- :patch -- = 0x0003

    0003 : 0009 ; -- <0080> a = leds
    0004 : 0601 ; -- <0081> b = 1
    0005 : c800 ; -- <0082> nop
    0006 : 2700 ; -- <0083> leds = a+b

-- :wait_key_press -- = 0x0007
    0007 : 0203 ; -- <0086> a = 0x03
    0008 : 040c ; -- <0087> b = keys
    0009 : c800 ; -- <0088> nop
    000a : e007 ; -- <0089> br eq :wait_key_press
    000b : 0007 ; -- <0089> "
-- :wait_key_release -- = 0x000c
    000c : 040c ; -- <0091> b = keys
    000d : c800 ; -- <0092> nop
    000e : e407 ; -- <0093> bn eq :wait_key_release
    000f : 000c ; -- <0093> "

-- getchar
-- b = 1
-- nop
-- putchar a+b

-- b = 85
-- putchar b

-- x = x+y
-- nop
-- a = x
-- call put4x

    0010 : 0264 ; -- <0108> a = 100
    0011 : fba0 ; -- <0109> call :spinwait
    0012 : 003b ; -- <0109> "
    0013 : fc00 ; -- <0109> "

-- b = 32
-- putchar b
-- m9k_addr = x
-- a = m9k_data
-- call put4x

-- b = 13
-- putchar b
-- b = 10
-- putchar b

    0014 : e00f ; -- <0122> jmp :patch
    0015 : 0003 ; -- <0122> "





-- using i as index into string.
    0016 : 0a00 ; -- <0129> i = 0

-- cache the string limit in g6.
    0017 : 0210 ; -- <0132> a = 16
    0018 : 0760 ; -- <0133> b = 0xffff
    0019 : c800 ; -- <0134> nop
    001a : 1b38 ; -- <0135> g6 = xor

-- :again -- = 0x001b
-- -- wait for keypress.
-- :wait_key_press
-- a = 0
-- b = keys
-- nop
-- br z :wait_key_press
-- :wait_key_release
-- b = keys
-- nop
-- bn z :wait_key_release

    001b : 0264 ; -- <0149> a = 100
    001c : fba0 ; -- <0150> call :spinwait
    001d : 003b ; -- <0150> "
    001e : fc00 ; -- <0150> "

-- increment LEDs
    001f : 0009 ; -- <0153> a = leds
    0020 : 0601 ; -- <0154> b = 1
    0021 : c800 ; -- <0155> nop
    0022 : 2700 ; -- <0156> leds = a+b

-- fetch a word from test pattern to the UART.  its low byte is a character.
    0023 : 0fa0 ; -- <0159> j = :msg
    0024 : 0032 ; -- <0159> "
    0025 : c800 ; -- <0160> nop
    0026 : d310 ; -- <0161> fetch a from i+j
    0027 : 03b0 ; -- <0161> "
--    putchar a

-- increment index & wrap around end of pattern.
    0028 : 0e01 ; -- <0165> j = 1
    0029 : c800 ; -- <0166> nop
    002a : 0b10 ; -- <0167> i = i+j
    002b : 0c06 ; -- <0168> j = g6
    002c : c800 ; -- <0169> nop
    002d : e401 ; -- <0170> bn 1z :no_wrap
    002e : 0030 ; -- <0170> "
    002f : 0a00 ; -- <0171> i = 0
-- :no_wrap -- = 0x0030

-- repeat forever.
    0030 : e00f ; -- <0175> jmp :again
    0031 : 001b ; -- <0175> "

-- :msg -- = 0x0032
-- "1234567890abcdef\n\x00"
    0032 : 3231 ; -- <0178> 21
    0033 : 3433 ; -- <0178> 43
    0034 : 3635 ; -- <0178> 65
    0035 : 3837 ; -- <0178> 87
    0036 : 3039 ; -- <0178> 09
    0037 : 6261 ; -- <0178> ba
    0038 : 6463 ; -- <0178> dc
    0039 : 6665 ; -- <0178> fe
    003a : 000a ; -- <0178>   

-- routine waits a number of milliseconds given in a.
    003b : 2004 ; -- <0181> push x -- func spinwait
    003c : 2005 ; -- <0181> push y -- "
    003d : 0760 ; -- <0182> b = -1
-- :spinwait_outer -- = 0x003e
    003e : 13a0 ; -- <0184> x = 12500
    003f : 30d4 ; -- <0184> "
    0040 : 1760 ; -- <0185> y = -1
    0041 : c800 ; -- <0186> nop
-- :spinwait_inner -- = 0x0042
    0042 : 1320 ; -- <0188> x = x+y
    0043 : c800 ; -- <0189> nop
    0044 : e400 ; -- <0190> bn 2z :spinwait_inner
    0045 : 0042 ; -- <0190> "
    0046 : 0300 ; -- <0191> a = a+b
    0047 : c800 ; -- <0192> nop
    0048 : e404 ; -- <0193> bn z :spinwait_outer
    0049 : 003e ; -- <0193> "
    004a : 1408 ; -- <0194> pop y -- return
    004b : 1008 ; -- <0194> pop x -- "
    004c : fc00 ; -- <0194> return

-- compute the modulus(255) of a number given in a.  return remainder in a.
    004d : 2006 ; -- <0197> push g6 -- func mod255
    004e : 2007 ; -- <0197> push g7 -- "
-- while a is greater than 254, subtract 255.
-- :mod255_again -- = 0x004f
    004f : 06fe ; -- <0200> b = 0xfe
    0050 : c800 ; -- <0201> nop
    0051 : e006 ; -- <0202> br gt :mod255_greater
    0052 : 0056 ; -- <0202> "
    0053 : 1c08 ; -- <0203> pop g7 -- return
    0054 : 1808 ; -- <0203> pop g6 -- "
    0055 : fc00 ; -- <0203> return
-- :mod255_greater -- = 0x0056
    0056 : 07a0 ; -- <0205> b = 0xff01
    0057 : ff01 ; -- <0205> "
    0058 : c800 ; -- <0206> nop
    0059 : 0300 ; -- <0207> a = a+b
    005a : e00f ; -- <0208> jmp :mod255_again
    005b : 004f ; -- <0208> "

-- set up Fletcher16 checksum algorithm to accumulate in the 2 given register names.

    005c : 1a00 ; -- <0218> fletcher16_init g6 g7
    005d : 1e00 ; -- <0218> "

-- accumulate a Fletcher16 checksum in g6 and g7,
-- given the next byte of data in a.
    005e : 2006 ; -- <0222> push g6 -- func fletcher16_input
    005f : 2007 ; -- <0222> push g7 -- "
    0060 : 203e ; -- <0222> push rtna -- "
--patch: need a way to declare summing registers as "static" or "preserve" so they're not auto-stacked.
    0061 : 0406 ; -- <0224> b = $fletcher_sum1_reg
    0062 : c800 ; -- <0225> nop
    0063 : 0300 ; -- <0226> a = a+b
    0064 : fba0 ; -- <0227> call :mod255
    0065 : 004d ; -- <0227> "
    0066 : fc00 ; -- <0227> "
    0067 : 1800 ; -- <0228> $fletcher_sum1_reg = a

    0068 : 0407 ; -- <0230> b = $fletcher_sum2_reg
    0069 : c800 ; -- <0231> nop
    006a : 0300 ; -- <0232> a = a+b
    006b : fba0 ; -- <0233> call :mod255
    006c : 004d ; -- <0233> "
    006d : fc00 ; -- <0233> "
    006e : 1c00 ; -- <0234> $fletcher_sum2_reg = a
    006f : f808 ; -- <0235> pop rtna -- return
    0070 : 1c08 ; -- <0235> pop g7 -- "
    0071 : 1808 ; -- <0235> pop g6 -- "
    0072 : fc00 ; -- <0235> return

-- return the combined 16-bit result of Fletcher16 checksum in a.
    0073 : 0007 ; -- <0239> a = $fletcher_sum2_reg
    0074 : 0352 ; -- <0240> a = a<<4
    0075 : 0352 ; -- <0241> a = a<<4
    0076 : 0406 ; -- <0242> b = $fletcher_sum1_reg
    0077 : c800 ; -- <0243> nop
    0078 : 0334 ; -- <0244> a = or
    0079 : fc00 ; -- <0245> return

        
        END;
    
