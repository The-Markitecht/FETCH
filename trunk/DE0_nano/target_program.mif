
        DEPTH = 1024 ;               -- The size of memory in words
        WIDTH = 16;                   -- bits per data word
        ADDRESS_RADIX = HEX;          
        DATA_RADIX = HEX;             
        CONTENT                       
        BEGIN
    
-- #########################################################################
-- assembly source code.
-- to write some data on the UART.

-- register file configuration

-- application-specific register aliases.

-- all Avalon addresses are BYTE addresses.  all Avalon sizes are in BYTES.
-- alias_both av_ctrl          [incr counter]
--    vdefine av_write_mask                   0x0001
-- alias_src  av_waitrequest   [incr counter]



-- :begin -- = 0x0000
    0000 : 2601 ; -- <0040> leds = 1
-- atx_ctrl = 0

-- a = 65
-- push a
-- a = 66
-- push a
-- a = 67
-- push a
-- a = 68
-- push a
-- a = 69
-- push a

-- pop b
-- putchar b
-- pop b
-- putchar b
-- pop b
-- putchar b
-- pop b
-- putchar b
-- pop b
-- putchar b

-- a = 0x1234
-- call put4x

-- x = 0x1234
-- y = 1
-- a = 0
-- :nextwrite
-- m9k_addr = a
-- m9k_data = x
-- x = x+y
-- b = 1
-- nop
-- a = a+b
-- b = 1024
-- nop
-- br lt :nextwrite

--patch
    0001 : 1200 ; -- <0083> x = 0
    0002 : 1601 ; -- <0084> y = 1
-- :patch -- = 0x0003

    0003 : 0009 ; -- <0087> a = leds
    0004 : 0601 ; -- <0088> b = 1
    0005 : c800 ; -- <0089> nop
    0006 : 2700 ; -- <0090> leds = a+b

-- Avalon write to JTAG UART.
    0007 : 0241 ; -- <0093> a = 65 -- putasc A
    0008 : 2800 ; -- <0093> putasc A
    0009 : 2fa0 ; -- <0093> "
    000a : 0200 ; -- <0093> "
    000b : 3200 ; -- <0093> "
    000c : 0242 ; -- <0094> a = 66 -- putasc B
    000d : 2800 ; -- <0094> putasc B
    000e : 2fa0 ; -- <0094> "
    000f : 0200 ; -- <0094> "
    0010 : 3200 ; -- <0094> "
    0011 : 0243 ; -- <0095> a = 67 -- putasc C
    0012 : 2800 ; -- <0095> putasc C
    0013 : 2fa0 ; -- <0095> "
    0014 : 0200 ; -- <0095> "
    0015 : 3200 ; -- <0095> "

-- Avalon read from JTAG UART.
-- :poll_jtag_uart -- = 0x0016
    0016 : 03a0 ; -- <0099> a = 1000
    0017 : 03e8 ; -- <0099> "
    0018 : fba0 ; -- <0100> call :spinwait
    0019 : 00d8 ; -- <0100> "
    001a : fc00 ; -- <0100> "

    001b : 03a0 ; -- <0102> a = 0x1234
    001c : 1234 ; -- <0102> "
    001d : fba0 ; -- <0103> call put4x
    001e : 0117 ; -- <0103> "
    001f : fc00 ; -- <0103> "
    0020 : 03a0 ; -- <0104> a = 1000
    0021 : 03e8 ; -- <0104> "
    0022 : fba0 ; -- <0105> call :spinwait
    0023 : 00d8 ; -- <0105> "
    0024 : fc00 ; -- <0105> "
    0025 : 022f ; -- <0106> a = 47 -- putasc "/"
    0026 : 2800 ; -- <0106> putasc "/"
    0027 : 2fa0 ; -- <0106> "
    0028 : 0200 ; -- <0106> "
    0029 : 3200 ; -- <0106> "
    002a : 03a0 ; -- <0107> a = 1000
    002b : 03e8 ; -- <0107> "
    002c : fba0 ; -- <0108> call :spinwait
    002d : 00d8 ; -- <0108> "
    002e : fc00 ; -- <0108> "
    002f : 2fa0 ; -- <0109> av_ad_hi = $jtag_uart_data_lsw_hi
    0030 : 0200 ; -- <0109> "
    0031 : 3200 ; -- <0110> av_ad_lo = $jtag_uart_data_lsw_lo
    0032 : 000a ; -- <0111> a = av_data
    0033 : fba0 ; -- <0112> call put4x
    0034 : 0117 ; -- <0112> "
    0035 : fc00 ; -- <0112> "
    0036 : 03a0 ; -- <0113> a = 1000
    0037 : 03e8 ; -- <0113> "
    0038 : fba0 ; -- <0114> call :spinwait
    0039 : 00d8 ; -- <0114> "
    003a : fc00 ; -- <0114> "
    003b : 022c ; -- <0115> a = 44 -- putasc ","
    003c : 2800 ; -- <0115> putasc ","
    003d : 2fa0 ; -- <0115> "
    003e : 0200 ; -- <0115> "
    003f : 3200 ; -- <0115> "
    0040 : 03a0 ; -- <0116> a = 1000
    0041 : 03e8 ; -- <0116> "
    0042 : fba0 ; -- <0117> call :spinwait
    0043 : 00d8 ; -- <0117> "
    0044 : fc00 ; -- <0117> "
    0045 : 2fa0 ; -- <0118> av_ad_hi = $jtag_uart_data_msw_hi
    0046 : 0200 ; -- <0118> "
    0047 : 3202 ; -- <0119> av_ad_lo = $jtag_uart_data_msw_lo
    0048 : 000a ; -- <0120> a = av_data
    0049 : fba0 ; -- <0121> call put4x
    004a : 0117 ; -- <0121> "
    004b : fc00 ; -- <0121> "
    004c : 03a0 ; -- <0122> a = 1000
    004d : 03e8 ; -- <0122> "
    004e : fba0 ; -- <0123> call :spinwait
    004f : 00d8 ; -- <0123> "
    0050 : fc00 ; -- <0123> "
    0051 : 022c ; -- <0124> a = 44 -- putasc ","
    0052 : 2800 ; -- <0124> putasc ","
    0053 : 2fa0 ; -- <0124> "
    0054 : 0200 ; -- <0124> "
    0055 : 3200 ; -- <0124> "
    0056 : 03a0 ; -- <0125> a = 1000
    0057 : 03e8 ; -- <0125> "
    0058 : fba0 ; -- <0126> call :spinwait
    0059 : 00d8 ; -- <0126> "
    005a : fc00 ; -- <0126> "
    005b : 2fa0 ; -- <0127> av_ad_hi = $jtag_uart_ctrl_lsw_hi
    005c : 0200 ; -- <0127> "
    005d : 3204 ; -- <0128> av_ad_lo = $jtag_uart_ctrl_lsw_lo
    005e : 000a ; -- <0129> a = av_data
    005f : fba0 ; -- <0130> call put4x
    0060 : 0117 ; -- <0130> "
    0061 : fc00 ; -- <0130> "
    0062 : 03a0 ; -- <0131> a = 1000
    0063 : 03e8 ; -- <0131> "
    0064 : fba0 ; -- <0132> call :spinwait
    0065 : 00d8 ; -- <0132> "
    0066 : fc00 ; -- <0132> "
    0067 : 022c ; -- <0133> a = 44 -- putasc ","
    0068 : 2800 ; -- <0133> putasc ","
    0069 : 2fa0 ; -- <0133> "
    006a : 0200 ; -- <0133> "
    006b : 3200 ; -- <0133> "
    006c : 03a0 ; -- <0134> a = 1000
    006d : 03e8 ; -- <0134> "
    006e : fba0 ; -- <0135> call :spinwait
    006f : 00d8 ; -- <0135> "
    0070 : fc00 ; -- <0135> "
    0071 : 2fa0 ; -- <0136> av_ad_hi = $jtag_uart_ctrl_msw_hi
    0072 : 0200 ; -- <0136> "
    0073 : 3206 ; -- <0137> av_ad_lo = $jtag_uart_ctrl_msw_lo
    0074 : 000a ; -- <0138> a = av_data
    0075 : fba0 ; -- <0139> call put4x
    0076 : 0117 ; -- <0139> "
    0077 : fc00 ; -- <0139> "
    0078 : 03a0 ; -- <0140> a = 1000
    0079 : 03e8 ; -- <0140> "
    007a : fba0 ; -- <0141> call :spinwait
    007b : 00d8 ; -- <0141> "
    007c : fc00 ; -- <0141> "
    007d : 022f ; -- <0142> a = 47 -- putasc "/"
    007e : 2800 ; -- <0142> putasc "/"
    007f : 2fa0 ; -- <0142> "
    0080 : 0200 ; -- <0142> "
    0081 : 3200 ; -- <0142> "
    0082 : 03a0 ; -- <0143> a = 1000
    0083 : 03e8 ; -- <0143> "
    0084 : fba0 ; -- <0144> call :spinwait
    0085 : 00d8 ; -- <0144> "
    0086 : fc00 ; -- <0144> "
    0087 : 03a0 ; -- <0145> a = 0x5678
    0088 : 5678 ; -- <0145> "
    0089 : fba0 ; -- <0146> call put4x
    008a : 0117 ; -- <0146> "
    008b : fc00 ; -- <0146> "
    008c : 03a0 ; -- <0147> a = 1000
    008d : 03e8 ; -- <0147> "
    008e : fba0 ; -- <0148> call :spinwait
    008f : 00d8 ; -- <0148> "
    0090 : fc00 ; -- <0148> "
    0091 : 020d ; -- <0149> a = 13 -- putasc "\r"
    0092 : 2800 ; -- <0149> putasc "\r"
    0093 : 2fa0 ; -- <0149> "
    0094 : 0200 ; -- <0149> "
    0095 : 3200 ; -- <0149> "
    0096 : 020a ; -- <0150> a = 10 -- putasc "\n"
    0097 : 2800 ; -- <0150> putasc "\n"
    0098 : 2fa0 ; -- <0150> "
    0099 : 0200 ; -- <0150> "
    009a : 3200 ; -- <0150> "

    009b : e00f ; -- <0152> jmp :poll_jtag_uart
    009c : 0016 ; -- <0152> "


-- Avalon write to SDRAM.  triggered by av_ad_lo.
    009d : 2ba0 ; -- <0156> av_data = 0x6789
    009e : 6789 ; -- <0156> "
    009f : 2e00 ; -- <0157> av_ad_hi = 0
    00a0 : 3220 ; -- <0158> av_ad_lo = 0x20
-- clear av_data so we can recognize if it doesn't get filled.
    00a1 : 2a00 ; -- <0160> av_data = 0
-- Avalon read from SDRAM.  triggered by av_ad_lo.
    00a2 : 000c ; -- <0162> a = av_ad_lo
    00a3 : 240a ; -- <0163> leds = av_data

-- :wait_key_press -- = 0x00a4
    00a4 : 0203 ; -- <0166> a = 0x03
    00a5 : 040d ; -- <0167> b = keys
    00a6 : c800 ; -- <0168> nop
    00a7 : e007 ; -- <0169> br eq :wait_key_press
    00a8 : 00a4 ; -- <0169> "
-- :wait_key_release -- = 0x00a9
    00a9 : 040d ; -- <0171> b = keys
    00aa : c800 ; -- <0172> nop
    00ab : e407 ; -- <0173> bn eq :wait_key_release
    00ac : 00a9 ; -- <0173> "

-- getchar
-- b = 1
-- nop
-- putchar a+b

-- b = 85
-- putchar b

-- x = x+y
-- nop
-- a = x
-- call put4x

    00ad : 0264 ; -- <0188> a = 100
    00ae : fba0 ; -- <0189> call :spinwait
    00af : 00d8 ; -- <0189> "
    00b0 : fc00 ; -- <0189> "

-- b = 32
-- putchar b
-- m9k_addr = x
-- a = m9k_data
-- call put4x

-- b = 13
-- putchar b
-- b = 10
-- putchar b

    00b1 : e00f ; -- <0202> jmp :patch
    00b2 : 0003 ; -- <0202> "





-- using i as index into string.
    00b3 : 0a00 ; -- <0209> i = 0

-- cache the string limit in g6.
    00b4 : 0210 ; -- <0212> a = 16
    00b5 : 0760 ; -- <0213> b = 0xffff
    00b6 : c800 ; -- <0214> nop
    00b7 : 1b38 ; -- <0215> g6 = xor

-- :again -- = 0x00b8
-- -- wait for keypress.
-- :wait_key_press
-- a = 0
-- b = keys
-- nop
-- br z :wait_key_press
-- :wait_key_release
-- b = keys
-- nop
-- bn z :wait_key_release

    00b8 : 0264 ; -- <0229> a = 100
    00b9 : fba0 ; -- <0230> call :spinwait
    00ba : 00d8 ; -- <0230> "
    00bb : fc00 ; -- <0230> "

-- increment LEDs
    00bc : 0009 ; -- <0233> a = leds
    00bd : 0601 ; -- <0234> b = 1
    00be : c800 ; -- <0235> nop
    00bf : 2700 ; -- <0236> leds = a+b

-- fetch a word from test pattern to the UART.  its low byte is a character.
    00c0 : 0fa0 ; -- <0239> j = :msg
    00c1 : 00cf ; -- <0239> "
    00c2 : c800 ; -- <0240> nop
    00c3 : d310 ; -- <0241> fetch a from i+j
    00c4 : 03b0 ; -- <0241> "
--    putchar a

-- increment index & wrap around end of pattern.
    00c5 : 0e01 ; -- <0245> j = 1
    00c6 : c800 ; -- <0246> nop
    00c7 : 0b10 ; -- <0247> i = i+j
    00c8 : 0c06 ; -- <0248> j = g6
    00c9 : c800 ; -- <0249> nop
    00ca : e401 ; -- <0250> bn 1z :no_wrap
    00cb : 00cd ; -- <0250> "
    00cc : 0a00 ; -- <0251> i = 0
-- :no_wrap -- = 0x00cd

-- repeat forever.
    00cd : e00f ; -- <0255> jmp :again
    00ce : 00b8 ; -- <0255> "

-- :msg -- = 0x00cf
-- "1234567890abcdef\n\x00"
    00cf : 3231 ; -- <0258> 21
    00d0 : 3433 ; -- <0258> 43
    00d1 : 3635 ; -- <0258> 65
    00d2 : 3837 ; -- <0258> 87
    00d3 : 3039 ; -- <0258> 09
    00d4 : 6261 ; -- <0258> ba
    00d5 : 6463 ; -- <0258> dc
    00d6 : 6665 ; -- <0258> fe
    00d7 : 000a ; -- <0258>   

-- routine waits a number of milliseconds given in a.
    00d8 : 2004 ; -- <0261> push x -- func spinwait
    00d9 : 2005 ; -- <0261> push y -- "
    00da : 0760 ; -- <0262> b = -1
-- :spinwait_outer -- = 0x00db
    00db : 13a0 ; -- <0264> x = 12500
    00dc : 30d4 ; -- <0264> "
    00dd : 1760 ; -- <0265> y = -1
    00de : c800 ; -- <0266> nop
-- :spinwait_inner -- = 0x00df
    00df : 1320 ; -- <0268> x = x+y
    00e0 : c800 ; -- <0269> nop
    00e1 : e400 ; -- <0270> bn 2z :spinwait_inner
    00e2 : 00df ; -- <0270> "
    00e3 : 0300 ; -- <0271> a = a+b
    00e4 : c800 ; -- <0272> nop
    00e5 : e404 ; -- <0273> bn z :spinwait_outer
    00e6 : 00db ; -- <0273> "
    00e7 : 1408 ; -- <0274> pop y -- return
    00e8 : 1008 ; -- <0274> pop x -- "
    00e9 : fc00 ; -- <0274> return

-- compute the modulus(255) of a number given in a.  return remainder in a.
    00ea : 2006 ; -- <0277> push g6 -- func mod255
    00eb : 2007 ; -- <0277> push g7 -- "
-- while a is greater than 254, subtract 255.
-- :mod255_again -- = 0x00ec
    00ec : 06fe ; -- <0280> b = 0xfe
    00ed : c800 ; -- <0281> nop
    00ee : e006 ; -- <0282> br gt :mod255_greater
    00ef : 00f3 ; -- <0282> "
    00f0 : 1c08 ; -- <0283> pop g7 -- return
    00f1 : 1808 ; -- <0283> pop g6 -- "
    00f2 : fc00 ; -- <0283> return
-- :mod255_greater -- = 0x00f3
    00f3 : 07a0 ; -- <0285> b = 0xff01
    00f4 : ff01 ; -- <0285> "
    00f5 : c800 ; -- <0286> nop
    00f6 : 0300 ; -- <0287> a = a+b
    00f7 : e00f ; -- <0288> jmp :mod255_again
    00f8 : 00ec ; -- <0288> "

-- set up Fletcher16 checksum algorithm to accumulate in the 2 given register names.

    00f9 : 1a00 ; -- <0298> fletcher16_init g6 g7
    00fa : 1e00 ; -- <0298> "

-- accumulate a Fletcher16 checksum in g6 and g7,
-- given the next byte of data in a.
    00fb : 2006 ; -- <0302> push g6 -- func fletcher16_input
    00fc : 2007 ; -- <0302> push g7 -- "
    00fd : 203e ; -- <0302> push rtna -- "
--patch: need a way to declare summing registers as "static" or "preserve" so they're not auto-stacked.
    00fe : 0406 ; -- <0304> b = $fletcher_sum1_reg
    00ff : c800 ; -- <0305> nop
    0100 : 0300 ; -- <0306> a = a+b
    0101 : fba0 ; -- <0307> call :mod255
    0102 : 00ea ; -- <0307> "
    0103 : fc00 ; -- <0307> "
    0104 : 1800 ; -- <0308> $fletcher_sum1_reg = a

    0105 : 0407 ; -- <0310> b = $fletcher_sum2_reg
    0106 : c800 ; -- <0311> nop
    0107 : 0300 ; -- <0312> a = a+b
    0108 : fba0 ; -- <0313> call :mod255
    0109 : 00ea ; -- <0313> "
    010a : fc00 ; -- <0313> "
    010b : 1c00 ; -- <0314> $fletcher_sum2_reg = a
    010c : f808 ; -- <0315> pop rtna -- return
    010d : 1c08 ; -- <0315> pop g7 -- "
    010e : 1808 ; -- <0315> pop g6 -- "
    010f : fc00 ; -- <0315> return

-- return the combined 16-bit result of Fletcher16 checksum in a.
    0110 : 0007 ; -- <0319> a = $fletcher_sum2_reg
    0111 : 0352 ; -- <0320> a = a<<4
    0112 : 0352 ; -- <0321> a = a<<4
    0113 : 0406 ; -- <0322> b = $fletcher_sum1_reg
    0114 : c800 ; -- <0323> nop
    0115 : 0334 ; -- <0324> a = or
    0116 : fc00 ; -- <0325> return

-- function to print a 16-bit number formatted as 4 hex digits.
-- pass number in a.
    0117 : 2004 ; -- <0329> push x -- func put4x
    0118 : 2006 ; -- <0329> push g6 -- "
    0119 : 203e ; -- <0329> push rtna -- "
    011a : 13a0 ; -- <0330> x = :hexdigits
    011b : 0154 ; -- <0330> "

    011c : 1800 ; -- <0332> g6 = a
    011d : 07a0 ; -- <0333> b = 0xF000
    011e : f000 ; -- <0333> "
    011f : c800 ; -- <0334> nop
    0120 : 0330 ; -- <0335> a = and
    0121 : 0353 ; -- <0336> a = a>>4
    0122 : 0353 ; -- <0337> a = a>>4
    0123 : 0353 ; -- <0338> a = a>>4
    0124 : fba0 ; -- <0339> call fetch_byte
    0125 : 015c ; -- <0339> "
    0126 : fc00 ; -- <0339> "
    0127 : 2800 ; -- <0340> putchar a
    0128 : 2fa0 ; -- <0340> "
    0129 : 0200 ; -- <0340> "
    012a : 3200 ; -- <0340> "

    012b : 0006 ; -- <0342> a = g6
    012c : 07a0 ; -- <0343> b = 0x0F00
    012d : 0f00 ; -- <0343> "
    012e : c800 ; -- <0344> nop
    012f : 0330 ; -- <0345> a = and
    0130 : 0353 ; -- <0346> a = a>>4
    0131 : 0353 ; -- <0347> a = a>>4
    0132 : fba0 ; -- <0348> call fetch_byte
    0133 : 015c ; -- <0348> "
    0134 : fc00 ; -- <0348> "
    0135 : 2800 ; -- <0349> putchar a
    0136 : 2fa0 ; -- <0349> "
    0137 : 0200 ; -- <0349> "
    0138 : 3200 ; -- <0349> "

    0139 : 0006 ; -- <0351> a = g6
    013a : 06f0 ; -- <0352> b = 0x00F0
    013b : c800 ; -- <0353> nop
    013c : 0330 ; -- <0354> a = and
    013d : 0353 ; -- <0355> a = a>>4
    013e : fba0 ; -- <0356> call fetch_byte
    013f : 015c ; -- <0356> "
    0140 : fc00 ; -- <0356> "
    0141 : 2800 ; -- <0357> putchar a
    0142 : 2fa0 ; -- <0357> "
    0143 : 0200 ; -- <0357> "
    0144 : 3200 ; -- <0357> "

    0145 : 0006 ; -- <0359> a = g6
    0146 : 060f ; -- <0360> b = 0x000F
    0147 : c800 ; -- <0361> nop
    0148 : 0330 ; -- <0362> a = and
    0149 : fba0 ; -- <0363> call fetch_byte
    014a : 015c ; -- <0363> "
    014b : fc00 ; -- <0363> "
    014c : 2800 ; -- <0364> putchar a
    014d : 2fa0 ; -- <0364> "
    014e : 0200 ; -- <0364> "
    014f : 3200 ; -- <0364> "

    0150 : f808 ; -- <0366> pop rtna -- return
    0151 : 1808 ; -- <0366> pop g6 -- "
    0152 : 1008 ; -- <0366> pop x -- "
    0153 : fc00 ; -- <0366> return

-- :hexdigits -- = 0x0154
-- "0123456789abcdef"
    0154 : 3130 ; -- <0369> 10
    0155 : 3332 ; -- <0369> 32
    0156 : 3534 ; -- <0369> 54
    0157 : 3736 ; -- <0369> 76
    0158 : 3938 ; -- <0369> 98
    0159 : 6261 ; -- <0369> ba
    015a : 6463 ; -- <0369> dc
    015b : 6665 ; -- <0369> fe

-- pick a byte from an array of words.  fetch & return it in a.
-- pass array base address in x, byte offset in a.
    015c : 0601 ; -- <0374> b = 1
    015d : c800 ; -- <0375> nop
    015e : e002 ; -- <0376> br and0z :pick_byte_even
    015f : 0168 ; -- <0376> "
    0160 : 0350 ; -- <0377> a = a>>1
    0161 : 0404 ; -- <0378> b = x
    0162 : c800 ; -- <0379> nop
    0163 : d300 ; -- <0380> fetch a from a+b
    0164 : 03b0 ; -- <0380> "
    0165 : 0353 ; -- <0381> a = a>>4
    0166 : 0353 ; -- <0382> a = a>>4
    0167 : fc00 ; -- <0383> return
-- :pick_byte_even -- = 0x0168
    0168 : 0350 ; -- <0385> a = a>>1
    0169 : 0404 ; -- <0386> b = x
    016a : c800 ; -- <0387> nop
    016b : d300 ; -- <0388> fetch a from a+b
    016c : 03b0 ; -- <0388> "
    016d : fc00 ; -- <0389> return

        
        END;
    
